- Primitives 
    - poseidon 
        - hash 2 number 
        - hash 3 number 
        - hash chunk 
    - sha256 
    - keccak256 
    - merkle 
        - calculate the leaf `leaf = poseidon_chunk(chunk) `
        - calculate the merkle root `leaf' = sha256(leaf || index)`: index start from 0 
        - calculate the merkle path `(leaf, index, path_hash_list)`
        - verify the merkle path: 
            - TBD
- Setup phase: 
    - generate a ciminion key set 
        - 3 numbers: MK0, MK1, nonce
        - we set IV = 123 
    - generate a 256-bit secret 
    - generate the VXOR 
        - `gen_VXOR(key, secret) -> ((c1, c2, c3), proof, h1, h2 )`
        - `c1 = MK0 xor poseidon(secret)`
        - `c2 = MK1 xor poseidon(secret || 1)`
        - `c3 = MK2 xor poseidon(secret || 2)`
    - proof claim that: 
        - c1, c2, c3 are correct 
        - `h1 = poseidon(MK0, MK1, MK2)`
        - `h2 = sha256(secret)`
    - verify VXOR 
        - `ver_vxor((c1, c2, c3), proof, h1, h2) -> bool`
- Delivery phase: 
    - hash of all chunks: 
        - `h = poseidon_chunk(chunk) `
    - build merkle root of all chunks 
        - `leaf = h`
        - `leaf' = sha256(h || index)`
        - build normal merkle tree from `leaf'`
    - verify the merkle root
        - recaculate 
    - encrypt a chunk
        - `enc_chunk_tweak(chunk_in, MK0, MK1, IV, nonce, index) -> chunk_out`
        - tweaked nonce is `poseidon(nonce || index)`
    - encryption commitment 
        - `enc_com(chunk_in, chunk_out, MK0, MK1, IV, nonce, index, pubkey) -> (h_in, h_out, h_key, index, signature)`
            - `h_in = poseidon_chunk(chunk_in)`
            - `h_out = poseidon_chunk(chunk_out)`
            - `h_key = poseidon_3(MK0, MK1, nonce)`
            - sign `(h_in, h_out, h_key, index)` using `pubkey`
    - verify the commitment chain 
        - verify the signature of each commitment
        - verify the consistency of the hashes. 
    - verify chunk
        - just check the poseidon hash of this chunk match the `h_out` of latest commitment.
        - check the commitment chain. 
- decryption phase: 
    - using xor get the keys. (reverse the vxor setup)
    - decrypt the chunk layer by layer 
    - locate the bad pub key 

- onchain contract design 
    - `join(pubkey, deposit)`
    - `leave(sig)`
    - `withdraw(sig)`
    - `PoF(com, pof, pubkey )`
        - inputs: 
            - `com = (h_in, h_out, h_key, index, signature)`
            - `pof `
        - output bool 
        - actions: 
            - check the commitment signature 
            - check the pof claim
            - fine the pubkey's depsit and transfer to the challenger 

